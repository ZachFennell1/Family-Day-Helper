// Generated by HLC 4.2.4 (HL v4)
#define HLC_BOOT
#include <hlc.h>
#include <haxe/crypto/Base64.h>
#include <haxe/crypto/BaseCode.h>
extern hl_type t$haxe_crypto_BaseCode;
extern haxe__crypto__$Base64 g$_haxe_crypto_Base64;
void haxe_crypto_BaseCode_new(haxe__crypto__BaseCode,haxe__io__Bytes);
haxe__io__Bytes haxe_crypto_BaseCode_encodeBytes(haxe__crypto__BaseCode,haxe__io__Bytes);
String haxe_io_Bytes_toString(haxe__io__Bytes);
extern String s$2063849;
String String___add__(String,String);
extern String s$43ec3e5;
#include <haxe/io/Encoding.h>
vdynamic* String_charCodeAt(String,int);
extern hl_type t$_i32;
String String_substr(String,int,vdynamic*);
haxe__io__Bytes haxe_io_Bytes_ofString(String,venum*);
haxe__io__Bytes haxe_crypto_BaseCode_decodeBytes(haxe__crypto__BaseCode,haxe__io__Bytes);

String haxe_crypto_Base64_encode(haxe__io__Bytes r0,bool* r1) {
	String r3, r10, r11;
	haxe__io__Bytes r4;
	bool r2;
	haxe__crypto__BaseCode r5;
	int r8, r9;
	haxe__crypto__$Base64 r6;
	if( r1 ) goto label$2e561f1_1_3;
	r2 = true;
	goto label$2e561f1_1_4;
	label$2e561f1_1_3:
	r2 = *r1;
	label$2e561f1_1_4:
	r5 = (haxe__crypto__BaseCode)hl_alloc_obj(&t$haxe_crypto_BaseCode);
	r6 = (haxe__crypto__$Base64)g$_haxe_crypto_Base64;
	r4 = r6->BYTES;
	haxe_crypto_BaseCode_new(r5,r4);
	r4 = haxe_crypto_BaseCode_encodeBytes(r5,r0);
	if( r4 == NULL ) hl_null_access();
	r3 = haxe_io_Bytes_toString(r4);
	if( !r2 ) goto label$2e561f1_1_25;
	if( r0 == NULL ) hl_null_access();
	r8 = r0->length;
	r9 = 3;
	r8 = r9 == 0 ? 0 : r8 % r9;
	switch(r8) {
		default:
		case 0:
			goto label$2e561f1_1_25;
		case 1:
			r11 = (String)s$2063849;
			r10 = String___add__(r3,r11);
			r3 = r10;
			goto label$2e561f1_1_25;
		case 2:
			r11 = (String)s$43ec3e5;
			r10 = String___add__(r3,r11);
			r3 = r10;
	}
	label$2e561f1_1_25:
	return r3;
}

haxe__io__Bytes haxe_crypto_Base64_decode(String r0,bool* r1) {
	String r5;
	venum *r12;
	haxe__io__Bytes r9;
	bool r2;
	haxe__crypto__BaseCode r10;
	vdynamic *r4, *r8;
	haxe__crypto__$Base64 r11;
	int r6, r7;
	if( r1 ) goto label$2e561f1_2_3;
	r2 = true;
	goto label$2e561f1_2_4;
	label$2e561f1_2_3:
	r2 = *r1;
	label$2e561f1_2_4:
	if( !r2 ) goto label$2e561f1_2_20;
	label$2e561f1_2_5:
	if( r0 == NULL ) hl_null_access();
	r6 = r0->length;
	r7 = 1;
	r6 = r6 - r7;
	r4 = String_charCodeAt(r0,r6);
	r6 = 61;
	r8 = hl_alloc_dynamic(&t$_i32);
	r8->v.i = r6;
	if( r4 != r8 && (!r4 || !r8 || (r4->v.i != r8->v.i)) ) goto label$2e561f1_2_20;
	r6 = 0;
	r7 = -1;
	r4 = hl_alloc_dynamic(&t$_i32);
	r4->v.i = r7;
	r5 = String_substr(r0,r6,r4);
	r0 = r5;
	goto label$2e561f1_2_5;
	label$2e561f1_2_20:
	r10 = (haxe__crypto__BaseCode)hl_alloc_obj(&t$haxe_crypto_BaseCode);
	r11 = (haxe__crypto__$Base64)g$_haxe_crypto_Base64;
	r9 = r11->BYTES;
	haxe_crypto_BaseCode_new(r10,r9);
	r12 = NULL;
	r9 = haxe_io_Bytes_ofString(r0,r12);
	r9 = haxe_crypto_BaseCode_decodeBytes(r10,r9);
	return r9;
}

