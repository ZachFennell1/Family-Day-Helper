// Generated by HLC 4.2.4 (HL v4)
#define HLC_BOOT
#include <hlc.h>
#include <hxd/_Pixels/PixelsFloatRGBA_Impl_.h>
#include <haxe/io/Bytes.h>
extern hl_type t$h3d_Vector;
void h3d_Vector_new(h3d__Vector,double*,double*,double*,double*);
double haxe_io_Bytes_getFloat(haxe__io__Bytes,int);
void haxe_io_Bytes_setFloat(haxe__io__Bytes,int,double);
#include <hxd/PixelFormat.h>
void hxd_Pixels_setFlip(hxd__Pixels,bool);
extern venum* g$hxd_PixelFormat_RGBA32F;
void hxd_Pixels_convert(hxd__Pixels,venum*);

h3d__Vector hxd__Pixels_PixelsFloatRGBA_Impl__getPixelF(hxd__Pixels r0,int r1,int r2,h3d__Vector r3) {
	haxe__io__Bytes r14;
	h3d__Vector r5;
	double r13;
	double *r6, *r7, *r8, *r9;
	int r10, r11, r12;
	if( r3 ) goto label$247bc3f_1_8;
	r5 = (h3d__Vector)hl_alloc_obj(&t$h3d_Vector);
	r6 = NULL;
	r7 = NULL;
	r8 = NULL;
	r9 = NULL;
	h3d_Vector_new(r5,r6,r7,r8,r9);
	r3 = r5;
	label$247bc3f_1_8:
	if( r0 == NULL ) hl_null_access();
	r12 = r0->width;
	r11 = r2 * r12;
	r10 = r1 + r11;
	r11 = 4;
	r10 = r10 << r11;
	r11 = r0->offset;
	r10 = r10 + r11;
	if( r3 == NULL ) hl_null_access();
	r14 = r0->bytes;
	if( r14 == NULL ) hl_null_access();
	r13 = haxe_io_Bytes_getFloat(r14,r10);
	r3->x = r13;
	r14 = r0->bytes;
	if( r14 == NULL ) hl_null_access();
	r12 = 4;
	r11 = r10 + r12;
	r13 = haxe_io_Bytes_getFloat(r14,r11);
	r3->y = r13;
	r14 = r0->bytes;
	if( r14 == NULL ) hl_null_access();
	r12 = 8;
	r11 = r10 + r12;
	r13 = haxe_io_Bytes_getFloat(r14,r11);
	r3->z = r13;
	r14 = r0->bytes;
	if( r14 == NULL ) hl_null_access();
	r12 = 12;
	r11 = r10 + r12;
	r13 = haxe_io_Bytes_getFloat(r14,r11);
	r3->w = r13;
	return r3;
}

void hxd__Pixels_PixelsFloatRGBA_Impl__setPixelF(hxd__Pixels r0,int r1,int r2,h3d__Vector r3) {
	haxe__io__Bytes r8;
	double r9;
	int r4, r5, r6;
	if( r0 == NULL ) hl_null_access();
	r6 = r0->width;
	r5 = r2 * r6;
	r4 = r1 + r5;
	r5 = 4;
	r4 = r4 << r5;
	r5 = r0->offset;
	r4 = r4 + r5;
	r8 = r0->bytes;
	if( r8 == NULL ) hl_null_access();
	if( r3 == NULL ) hl_null_access();
	r9 = r3->x;
	haxe_io_Bytes_setFloat(r8,r4,r9);
	r8 = r0->bytes;
	if( r8 == NULL ) hl_null_access();
	r6 = 4;
	r5 = r4 + r6;
	r9 = r3->y;
	haxe_io_Bytes_setFloat(r8,r5,r9);
	r8 = r0->bytes;
	if( r8 == NULL ) hl_null_access();
	r6 = 8;
	r5 = r4 + r6;
	r9 = r3->z;
	haxe_io_Bytes_setFloat(r8,r5,r9);
	r8 = r0->bytes;
	if( r8 == NULL ) hl_null_access();
	r6 = 12;
	r5 = r4 + r6;
	r9 = r3->w;
	haxe_io_Bytes_setFloat(r8,r5,r9);
	return;
}

hxd__Pixels hxd__Pixels_PixelsFloatRGBA_Impl__fromPixels(hxd__Pixels r0) {
	venum *r3;
	bool r2;
	if( r0 == NULL ) hl_null_access();
	r2 = false;
	hxd_Pixels_setFlip(r0,r2);
	r3 = (venum*)g$hxd_PixelFormat_RGBA32F;
	hxd_Pixels_convert(r0,r3);
	return r0;
}

